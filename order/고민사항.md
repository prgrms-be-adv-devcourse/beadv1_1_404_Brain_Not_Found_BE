# 고민사항

## 주문 상태 변경 설계
- 주문 상태 전이를 `OrderStatus` 내부에서 어떻게 검증할지 고민함.  
  - `canTransitionTo` 메서드로 현재 상태에서 가능한 목표 상태를 명시하는 방식이 가장 명확하다고 판단.
- 서비스 계층에서 `switch`문을 사용할지, 단일 메서드 호출로 마칠지 논의함.  
  - 전이 검증과 부가 로직이 없다면 `order.changeStatus()` 한 줄로 충분하지만, 도메인 규칙이 늘어날 가능성을 고려해 확장 가능성을 점검함.
- 트랜잭션과 더티 체킹 동작에 대한 질문.  
  - `@Transactional` 환경에서 `changeStatus`만 호출해도 DB에 반영된다는 점 확인.

## 주문 검증 (OrderValidate)
- 언제 주문 코드를 받는지에 대한 혼동 정리.  
  - 주문 생성 이전 검증 단계에서는 주문 코드가 없으므로 상품·구매자 정보를 RequestBody로 받도록 설계.
- 검증 시 구매자 정보를 왜 확인하는지 질문.  
  - 권한, 배송 가능 주소, 정책 적용 등을 위해 필요하다는 결론.
- 상품 검증 과정 정리.  
  - 재고, 판매 상태, 가격 일치 여부 등을 확인해야 하며, 상품 서비스로부터 최신 정보를 받아 검증하도록 구조화.
- DTO 설계 고민.  
  - `OrderValidateRequest`에 상품 목록과 가격을 포함하고 Bean Validation을 적용.
- 응답 DTO 필요성 검토.  
  - 상태 변경/검증 후 클라이언트에서 활용할 정보(최종 상태, 타임스탬프, 합계 등)를 전달하기 위해 Response record 도입.

## Optional 활용
- 서비스 내부에서 클라이언트 호출 후 null 체크를 간결하게 하기 위해 Optional을 사용할 수 있는지 질문.  
  - `Optional.ofNullable(...).orElseThrow(...)` 패턴으로 공통 헬퍼를 만들고 재사용하는 방식으로 정리.
- 컨트롤러 레벨에서 Optional 사용 여부도 언급됐지만, 도메인 서비스 내부 헬퍼로 국한하는 게 적절하다고 판단.

## 컨트롤러 요청/응답 구조
- 상태 변경 API에서 어떤 파라미터를 받을지, `PathVariable`과 `RequestBody`의 역할을 구분하는 방법을 논의.
- `Pageable` 활용을 검토하고, `@PageableDefault`를 적용해 페이징 파라미터를 단순화.
- 공통 응답 포맷 필요성.  
  - `BaseResponse`를 적용해 주문/결제 모듈에서 동일한 응답 구조를 사용하도록 수정.

## 테스트 코드 정합성
- 실 구현과 다른 DTO/엔티티 필드를 사용한 테스트 코드 문제 발견.  
  - `ProductResponse`, `OrderCreateResponse` 등 실제 시그니처에 맞게 테스트 수정을 진행.
- Mockito strict stubbing 오류.  
  - 저장 직후 `findByOrderId(null)` 호출로 인해 발생했고, stubbing을 `any()`로 바꿔 해결.

## 기타 도메인 질문
- 주문 검증 시 필요한 검증 흐름(구매자 권한, 재고, 정책 등) 재정리.
- 주문 삭제/취소 UI 제공 방식에 대한 레퍼런스 확인.
- 예치금(QueryDSL) 쿼리 샘플을 검토하며 역할 파악 (기간 + 페이징 조회).

위 고민 과정을 문서화해 두어 이후 설계/개발 시 참고할 수 있도록 정리함.

